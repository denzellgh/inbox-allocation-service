// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: conversation_refs.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createConversationRef = `-- name: CreateConversationRef :exec
INSERT INTO conversation_refs (
    id, tenant_id, inbox_id, external_conversation_id, customer_phone_number,
    state, assigned_operator_id, last_message_at, message_count, priority_score,
    created_at, updated_at, resolved_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type CreateConversationRefParams struct {
	ID                     pgtype.UUID        `json:"id"`
	TenantID               pgtype.UUID        `json:"tenant_id"`
	InboxID                pgtype.UUID        `json:"inbox_id"`
	ExternalConversationID string             `json:"external_conversation_id"`
	CustomerPhoneNumber    string             `json:"customer_phone_number"`
	State                  ConversationState  `json:"state"`
	AssignedOperatorID     pgtype.UUID        `json:"assigned_operator_id"`
	LastMessageAt          pgtype.Timestamptz `json:"last_message_at"`
	MessageCount           int32              `json:"message_count"`
	PriorityScore          pgtype.Numeric     `json:"priority_score"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	ResolvedAt             pgtype.Timestamptz `json:"resolved_at"`
}

func (q *Queries) CreateConversationRef(ctx context.Context, arg CreateConversationRefParams) error {
	_, err := q.db.Exec(ctx, createConversationRef,
		arg.ID,
		arg.TenantID,
		arg.InboxID,
		arg.ExternalConversationID,
		arg.CustomerPhoneNumber,
		arg.State,
		arg.AssignedOperatorID,
		arg.LastMessageAt,
		arg.MessageCount,
		arg.PriorityScore,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ResolvedAt,
	)
	return err
}

const deleteConversationRef = `-- name: DeleteConversationRef :exec
DELETE FROM conversation_refs WHERE id = $1
`

func (q *Queries) DeleteConversationRef(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteConversationRef, id)
	return err
}

const getConversationRefByExternalID = `-- name: GetConversationRefByExternalID :one
SELECT id, tenant_id, inbox_id, external_conversation_id, customer_phone_number, state, assigned_operator_id, last_message_at, message_count, priority_score, created_at, updated_at, resolved_at FROM conversation_refs 
WHERE tenant_id = $1 AND external_conversation_id = $2
`

type GetConversationRefByExternalIDParams struct {
	TenantID               pgtype.UUID `json:"tenant_id"`
	ExternalConversationID string      `json:"external_conversation_id"`
}

func (q *Queries) GetConversationRefByExternalID(ctx context.Context, arg GetConversationRefByExternalIDParams) (ConversationRef, error) {
	row := q.db.QueryRow(ctx, getConversationRefByExternalID, arg.TenantID, arg.ExternalConversationID)
	var i ConversationRef
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.InboxID,
		&i.ExternalConversationID,
		&i.CustomerPhoneNumber,
		&i.State,
		&i.AssignedOperatorID,
		&i.LastMessageAt,
		&i.MessageCount,
		&i.PriorityScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const getConversationRefByID = `-- name: GetConversationRefByID :one
SELECT id, tenant_id, inbox_id, external_conversation_id, customer_phone_number, state, assigned_operator_id, last_message_at, message_count, priority_score, created_at, updated_at, resolved_at FROM conversation_refs WHERE id = $1
`

func (q *Queries) GetConversationRefByID(ctx context.Context, id pgtype.UUID) (ConversationRef, error) {
	row := q.db.QueryRow(ctx, getConversationRefByID, id)
	var i ConversationRef
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.InboxID,
		&i.ExternalConversationID,
		&i.CustomerPhoneNumber,
		&i.State,
		&i.AssignedOperatorID,
		&i.LastMessageAt,
		&i.MessageCount,
		&i.PriorityScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const getConversationsByInbox = `-- name: GetConversationsByInbox :many
SELECT id, tenant_id, inbox_id, external_conversation_id, customer_phone_number, state, assigned_operator_id, last_message_at, message_count, priority_score, created_at, updated_at, resolved_at FROM conversation_refs
WHERE tenant_id = $1 AND inbox_id = $2
ORDER BY created_at DESC
LIMIT $3
`

type GetConversationsByInboxParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	InboxID  pgtype.UUID `json:"inbox_id"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) GetConversationsByInbox(ctx context.Context, arg GetConversationsByInboxParams) ([]ConversationRef, error) {
	rows, err := q.db.Query(ctx, getConversationsByInbox, arg.TenantID, arg.InboxID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConversationRef{}
	for rows.Next() {
		var i ConversationRef
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InboxID,
			&i.ExternalConversationID,
			&i.CustomerPhoneNumber,
			&i.State,
			&i.AssignedOperatorID,
			&i.LastMessageAt,
			&i.MessageCount,
			&i.PriorityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsByOperatorAndState = `-- name: GetConversationsByOperatorAndState :many
SELECT id, tenant_id, inbox_id, external_conversation_id, customer_phone_number, state, assigned_operator_id, last_message_at, message_count, priority_score, created_at, updated_at, resolved_at FROM conversation_refs
WHERE tenant_id = $1 
  AND assigned_operator_id = $2 
  AND state = $3
ORDER BY created_at DESC
`

type GetConversationsByOperatorAndStateParams struct {
	TenantID           pgtype.UUID       `json:"tenant_id"`
	AssignedOperatorID pgtype.UUID       `json:"assigned_operator_id"`
	State              ConversationState `json:"state"`
}

func (q *Queries) GetConversationsByOperatorAndState(ctx context.Context, arg GetConversationsByOperatorAndStateParams) ([]ConversationRef, error) {
	rows, err := q.db.Query(ctx, getConversationsByOperatorAndState, arg.TenantID, arg.AssignedOperatorID, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConversationRef{}
	for rows.Next() {
		var i ConversationRef
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InboxID,
			&i.ExternalConversationID,
			&i.CustomerPhoneNumber,
			&i.State,
			&i.AssignedOperatorID,
			&i.LastMessageAt,
			&i.MessageCount,
			&i.PriorityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsByOperatorID = `-- name: GetConversationsByOperatorID :many
SELECT id, tenant_id, inbox_id, external_conversation_id, customer_phone_number, state, assigned_operator_id, last_message_at, message_count, priority_score, created_at, updated_at, resolved_at FROM conversation_refs
WHERE tenant_id = $1 AND assigned_operator_id = $2
ORDER BY created_at DESC
`

type GetConversationsByOperatorIDParams struct {
	TenantID           pgtype.UUID `json:"tenant_id"`
	AssignedOperatorID pgtype.UUID `json:"assigned_operator_id"`
}

func (q *Queries) GetConversationsByOperatorID(ctx context.Context, arg GetConversationsByOperatorIDParams) ([]ConversationRef, error) {
	rows, err := q.db.Query(ctx, getConversationsByOperatorID, arg.TenantID, arg.AssignedOperatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConversationRef{}
	for rows.Next() {
		var i ConversationRef
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InboxID,
			&i.ExternalConversationID,
			&i.CustomerPhoneNumber,
			&i.State,
			&i.AssignedOperatorID,
			&i.LastMessageAt,
			&i.MessageCount,
			&i.PriorityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationsByTenantAndState = `-- name: GetConversationsByTenantAndState :many
SELECT id, tenant_id, inbox_id, external_conversation_id, customer_phone_number, state, assigned_operator_id, last_message_at, message_count, priority_score, created_at, updated_at, resolved_at FROM conversation_refs
WHERE tenant_id = $1 AND state = $2
ORDER BY created_at DESC
LIMIT $3
`

type GetConversationsByTenantAndStateParams struct {
	TenantID pgtype.UUID       `json:"tenant_id"`
	State    ConversationState `json:"state"`
	Limit    int32             `json:"limit"`
}

func (q *Queries) GetConversationsByTenantAndState(ctx context.Context, arg GetConversationsByTenantAndStateParams) ([]ConversationRef, error) {
	rows, err := q.db.Query(ctx, getConversationsByTenantAndState, arg.TenantID, arg.State, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConversationRef{}
	for rows.Next() {
		var i ConversationRef
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InboxID,
			&i.ExternalConversationID,
			&i.CustomerPhoneNumber,
			&i.State,
			&i.AssignedOperatorID,
			&i.LastMessageAt,
			&i.MessageCount,
			&i.PriorityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextConversationsForAllocation = `-- name: GetNextConversationsForAllocation :many
SELECT id, tenant_id, inbox_id, external_conversation_id, customer_phone_number, state, assigned_operator_id, last_message_at, message_count, priority_score, created_at, updated_at, resolved_at FROM conversation_refs
WHERE tenant_id = $1 
  AND inbox_id = ANY($2::uuid[])
  AND state = 'QUEUED'
ORDER BY priority_score DESC, last_message_at ASC
LIMIT $3
FOR UPDATE SKIP LOCKED
`

type GetNextConversationsForAllocationParams struct {
	TenantID pgtype.UUID   `json:"tenant_id"`
	Column2  []pgtype.UUID `json:"column_2"`
	Limit    int32         `json:"limit"`
}

// CRITICAL: Allocation query with FOR UPDATE SKIP LOCKED
func (q *Queries) GetNextConversationsForAllocation(ctx context.Context, arg GetNextConversationsForAllocationParams) ([]ConversationRef, error) {
	rows, err := q.db.Query(ctx, getNextConversationsForAllocation, arg.TenantID, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConversationRef{}
	for rows.Next() {
		var i ConversationRef
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InboxID,
			&i.ExternalConversationID,
			&i.CustomerPhoneNumber,
			&i.State,
			&i.AssignedOperatorID,
			&i.LastMessageAt,
			&i.MessageCount,
			&i.PriorityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueuedConversationsByTenant = `-- name: GetQueuedConversationsByTenant :many
SELECT id, tenant_id, inbox_id, external_conversation_id, customer_phone_number, state, assigned_operator_id, last_message_at, message_count, priority_score, created_at, updated_at, resolved_at FROM conversation_refs
WHERE tenant_id = $1 AND state = 'QUEUED'
ORDER BY priority_score DESC, last_message_at ASC
LIMIT $2
`

type GetQueuedConversationsByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) GetQueuedConversationsByTenant(ctx context.Context, arg GetQueuedConversationsByTenantParams) ([]ConversationRef, error) {
	rows, err := q.db.Query(ctx, getQueuedConversationsByTenant, arg.TenantID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConversationRef{}
	for rows.Next() {
		var i ConversationRef
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InboxID,
			&i.ExternalConversationID,
			&i.CustomerPhoneNumber,
			&i.State,
			&i.AssignedOperatorID,
			&i.LastMessageAt,
			&i.MessageCount,
			&i.PriorityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockConversationForClaim = `-- name: LockConversationForClaim :one
SELECT id, tenant_id, inbox_id, external_conversation_id, customer_phone_number, state, assigned_operator_id, last_message_at, message_count, priority_score, created_at, updated_at, resolved_at FROM conversation_refs
WHERE id = $1 AND state = 'QUEUED'
FOR UPDATE NOWAIT
`

// CRITICAL: Lock specific conversation for claim
func (q *Queries) LockConversationForClaim(ctx context.Context, id pgtype.UUID) (ConversationRef, error) {
	row := q.db.QueryRow(ctx, lockConversationForClaim, id)
	var i ConversationRef
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.InboxID,
		&i.ExternalConversationID,
		&i.CustomerPhoneNumber,
		&i.State,
		&i.AssignedOperatorID,
		&i.LastMessageAt,
		&i.MessageCount,
		&i.PriorityScore,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const searchConversationsByPhone = `-- name: SearchConversationsByPhone :many
SELECT id, tenant_id, inbox_id, external_conversation_id, customer_phone_number, state, assigned_operator_id, last_message_at, message_count, priority_score, created_at, updated_at, resolved_at FROM conversation_refs
WHERE tenant_id = $1 AND customer_phone_number = $2
ORDER BY created_at DESC
`

type SearchConversationsByPhoneParams struct {
	TenantID            pgtype.UUID `json:"tenant_id"`
	CustomerPhoneNumber string      `json:"customer_phone_number"`
}

func (q *Queries) SearchConversationsByPhone(ctx context.Context, arg SearchConversationsByPhoneParams) ([]ConversationRef, error) {
	rows, err := q.db.Query(ctx, searchConversationsByPhone, arg.TenantID, arg.CustomerPhoneNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConversationRef{}
	for rows.Next() {
		var i ConversationRef
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.InboxID,
			&i.ExternalConversationID,
			&i.CustomerPhoneNumber,
			&i.State,
			&i.AssignedOperatorID,
			&i.LastMessageAt,
			&i.MessageCount,
			&i.PriorityScore,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConversationRef = `-- name: UpdateConversationRef :exec
UPDATE conversation_refs
SET inbox_id = $2,
    state = $3,
    assigned_operator_id = $4,
    last_message_at = $5,
    message_count = $6,
    priority_score = $7,
    updated_at = $8,
    resolved_at = $9
WHERE id = $1
`

type UpdateConversationRefParams struct {
	ID                 pgtype.UUID        `json:"id"`
	InboxID            pgtype.UUID        `json:"inbox_id"`
	State              ConversationState  `json:"state"`
	AssignedOperatorID pgtype.UUID        `json:"assigned_operator_id"`
	LastMessageAt      pgtype.Timestamptz `json:"last_message_at"`
	MessageCount       int32              `json:"message_count"`
	PriorityScore      pgtype.Numeric     `json:"priority_score"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ResolvedAt         pgtype.Timestamptz `json:"resolved_at"`
}

func (q *Queries) UpdateConversationRef(ctx context.Context, arg UpdateConversationRefParams) error {
	_, err := q.db.Exec(ctx, updateConversationRef,
		arg.ID,
		arg.InboxID,
		arg.State,
		arg.AssignedOperatorID,
		arg.LastMessageAt,
		arg.MessageCount,
		arg.PriorityScore,
		arg.UpdatedAt,
		arg.ResolvedAt,
	)
	return err
}

const updateConversationState = `-- name: UpdateConversationState :exec
UPDATE conversation_refs
SET state = $2,
    assigned_operator_id = $3,
    updated_at = $4,
    resolved_at = $5
WHERE id = $1
`

type UpdateConversationStateParams struct {
	ID                 pgtype.UUID        `json:"id"`
	State              ConversationState  `json:"state"`
	AssignedOperatorID pgtype.UUID        `json:"assigned_operator_id"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ResolvedAt         pgtype.Timestamptz `json:"resolved_at"`
}

// Update state only (for allocation/deallocate/resolve)
func (q *Queries) UpdateConversationState(ctx context.Context, arg UpdateConversationStateParams) error {
	_, err := q.db.Exec(ctx, updateConversationState,
		arg.ID,
		arg.State,
		arg.AssignedOperatorID,
		arg.UpdatedAt,
		arg.ResolvedAt,
	)
	return err
}
