// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: operators.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOperator = `-- name: CreateOperator :exec
INSERT INTO operators (id, tenant_id, role, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateOperatorParams struct {
	ID        pgtype.UUID        `json:"id"`
	TenantID  pgtype.UUID        `json:"tenant_id"`
	Role      OperatorRole       `json:"role"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateOperator(ctx context.Context, arg CreateOperatorParams) error {
	_, err := q.db.Exec(ctx, createOperator,
		arg.ID,
		arg.TenantID,
		arg.Role,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteOperator = `-- name: DeleteOperator :exec
DELETE FROM operators WHERE id = $1
`

func (q *Queries) DeleteOperator(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOperator, id)
	return err
}

const getOperatorByID = `-- name: GetOperatorByID :one
SELECT id, tenant_id, role, created_at, updated_at FROM operators WHERE id = $1
`

func (q *Queries) GetOperatorByID(ctx context.Context, id pgtype.UUID) (Operator, error) {
	row := q.db.QueryRow(ctx, getOperatorByID, id)
	var i Operator
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOperatorsByTenantAndRole = `-- name: GetOperatorsByTenantAndRole :many
SELECT id, tenant_id, role, created_at, updated_at FROM operators WHERE tenant_id = $1 AND role = $2 ORDER BY created_at DESC
`

type GetOperatorsByTenantAndRoleParams struct {
	TenantID pgtype.UUID  `json:"tenant_id"`
	Role     OperatorRole `json:"role"`
}

func (q *Queries) GetOperatorsByTenantAndRole(ctx context.Context, arg GetOperatorsByTenantAndRoleParams) ([]Operator, error) {
	rows, err := q.db.Query(ctx, getOperatorsByTenantAndRole, arg.TenantID, arg.Role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Operator{}
	for rows.Next() {
		var i Operator
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperatorsByTenantID = `-- name: GetOperatorsByTenantID :many
SELECT id, tenant_id, role, created_at, updated_at FROM operators WHERE tenant_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetOperatorsByTenantID(ctx context.Context, tenantID pgtype.UUID) ([]Operator, error) {
	rows, err := q.db.Query(ctx, getOperatorsByTenantID, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Operator{}
	for rows.Next() {
		var i Operator
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOperator = `-- name: UpdateOperator :exec
UPDATE operators
SET role = $2,
    updated_at = $3
WHERE id = $1
`

type UpdateOperatorParams struct {
	ID        pgtype.UUID        `json:"id"`
	Role      OperatorRole       `json:"role"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateOperator(ctx context.Context, arg UpdateOperatorParams) error {
	_, err := q.db.Exec(ctx, updateOperator, arg.ID, arg.Role, arg.UpdatedAt)
	return err
}
